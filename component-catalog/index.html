<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>NoRedInk style guide</title>
    <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
    <link
      href="https://fonts.googleapis.com/css?family=Muli:400,400i,600,600i,700,700i,800,800i,900,900i"
      rel="stylesheet"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <div id="svg-target"></div>
    <script src="elm.js"></script>
    <script>
      const app = Elm.Main.init();

      // HIGHLIGHTER

      // start listening to events when the user starts dragging/clickingdown
      app.ports.highlighterListen.subscribe(([id, scrollFriendly]) => {
        const touchMoveListener = handleTouchEvents("move", id);

        window.requestAnimationFrame(() => {
          var highlighter = document.getElementById(id);
          if (!id || !highlighter) {
            // in a real application, report an error at this point.
            console.log("highlighter not found", id);
            return;
          }

          // TODO: At some point we do not need those event listeners. It would be nice to remove them.
          // Example: when we send a Guided Draft back for revisions: no highlighters needed anymore!
          //
          // Register global listeners for when we release the mouse/touchpad outside a highlighter
          highlighter.addEventListener("mousedown", (_) => {
            console.log("registering mouseup handler");
            document.addEventListener("mouseup", onDocumentUp(id, "mouse"), {once: true});
          });
          highlighter.addEventListener("touchstart", (_) => {
            console.log("registering touchend handler");
            document.addEventListener("touchend", onDocumentUp(id, "touch"), {once: true});
          });
          if (!scrollFriendly) {
            // scroll-friendly mode only registers a touchmove listener after a longpress
            highlighter.addEventListener("touchmove", touchMoveListener);
          }
          highlighter.addEventListener("touchstart", handleTouchStartScrollFriendly(id));
        });

        /*
         * This simulates "long-press to highlight" behavior that's native to mobile devices.
         *
         * We can't respect native long-press delays, unfortunately, because iOS does not implement
         * an event that relies on long-press that we can intercept, like Android's `contextmenu`.
         *
         * The trick to make this work and be scroll friendly:
         * - On touchstart, start a 500ms timer
         * - If touch moves of ends before timer is done, undo everything (it's not a long-press)
         * - If 500ms timer succeeds..
         *   - send a longpress event to Elm so we start hinting
         *   - add a touchmove listener
         *     - on touchmove, tell Elm which element is currently under the finger
         *   - add a touchend listener so we can stop hinting regardless of where we are in the page
         *
         * How this makes it scroll friendly: preventDefault on touchmove is only triggered after
         * the longpress, so simple swipes up and down are not affected.
         */
        function handleTouchStartScrollFriendly(id) {
          return (e) => {
            if (window.debugHighlighter) {
              console.log("touchstart", id);
            }

            const idx = getTouchEventHighlightableIndex(e);

            if (!idx) return;

            const longpressTimeout = setTimeout(() => {
              if (window.debugHighlighter) {
                console.log("longpress", id, idx);
              }
              document.getElementById(id).addEventListener("touchmove", touchMoveListener);
              document.removeEventListener("touchmove", cancelLongpress);
              document.removeEventListener("touchend", cancelLongpress);
              app.ports.highlighterOnTouch.send(["longpress", id, idx]);
            }, 500);

            // on touchmove or touchend, cancel the longpress timeout
            function cancelLongpress() {
              if (window.debugHighlighter) {
                console.log("cancel longpress", id, idx);
              }
              clearTimeout(longpressTimeout);
              document.removeEventListener("touchmove", cancelLongpress);
              document.removeEventListener("touchend", cancelLongpress);
            }

            document.addEventListener("touchmove", cancelLongpress);
            document.addEventListener("touchend", cancelLongpress);
          };
        }


        /*
        * Touchmove event always fire on the element that got the initial touchstart event.
        * We need the element under the finger to highlight a section though.
        */
        function handleTouchEvents(type, id) {
          if (window.debugHighlighter) {
            console.log("handleTouchEvents", type, id);
          }
          return function (e) {
            if (window.debugHighlighter) {
              console.log("touch event:", type, id);
            }
            e.preventDefault();
            e.stopPropagation();
            
            let highlightableIndex = getTouchEventHighlightableIndex(e);
            if (highlightableIndex) {
              app.ports.highlighterOnTouch.send([type, id, highlightableIndex]);
            }
          };
        }

        /*
        * inform elm when we receive a mouseup/touchend event.
        */
        function onDocumentUp(id, device) {
          return function () {
            app.ports.highlighterOnDocumentUp.send([id, device]);
            if (device === "touch") {
              if (window.debugHighlighter) {
                console.log("deregistering touch listeners");
              }
              // Stop listening to touchmove after touchend
              // This helps us not report touchmove when touch starts on one highlighter and moves
              // into another
              document.getElementById(id)?.removeEventListener("touchmove", touchMoveListener);
            }
          };
        }

        function getTouchEventHighlightableIndex(e) {
          // we don't care about multitouch
          if (e.touches.length > 1) return;

          var loc = e.changedTouches[0];

          if (!loc) throw "touch event unexpectedly didn't have any touches!";

          // get the element under the finger
          var realTarget = document.elementFromPoint(loc.clientX, loc.clientY);

          if (realTarget) {
            // each word has a data attribute with its index.
            const data = realTarget.getAttribute("data-highlighter-item-index");
            if (data) {
              return parseInt(data, 10);
            }
          }
        }
      });
    </script>
    <script src="bundle.js"></script>
  </body>
</html>
