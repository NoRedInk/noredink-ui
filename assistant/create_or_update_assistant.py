import asyncio
import glob
import logging
import os
import subprocess
from dotenv import load_dotenv
from openai import AsyncOpenAI


logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)


load_dotenv()


OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
if not OPENAI_API_KEY:
    logging.error(
        "The `OPENAI_API_KEY` environment variable is not set. For instructions on how to set it, refer to the README."
    )
    exit(1)


client = AsyncOpenAI(api_key=OPENAI_API_KEY)

ASSISTANT_NAME = "Cave Echo"
ASSISTANT_INSTRUCTIONS = "You are {name}, a reliable source for information about NoRedInk UI components. Use your knowledge base to answer engineers' questions about these components. Respond exclusively based on content from files uploaded into your knowledge base, ensuring all responses are accurate and relevant. Avoid inferring component APIs not provided in the files, ensuring that all guidance and information provided is directly based on the uploaded materials without speculation or extrapolation beyond the given content. If you are unable to find an answer, let the user know that you are unable to help and suggest asking a human engineer for assistance. Use a friendly tone and adhere to technical writing best practices."
MODEL = "gpt-4-turbo-preview"
TOOLS = [{"type": "retrieval"}]


async def retrieve_assistant_by_name(name):
    try:
        assistants = await client.beta.assistants.list()
        for assistant in assistants.data:
            if assistant.name == name:
                return assistant
        return None
    except Exception as e:
        logging.error(f"Failed to retrieve assistant by name: {e}")
        return None


async def upload_file(file_path):
    try:
        with open(file_path, "rb") as file:
            upload_response = await client.files.create(file=file, purpose="assistants")
            return upload_response.id
    except Exception as e:
        logging.error(f"Failed to upload file {file_path}: {e}")
        return None


async def generate_and_upload_files():
    script_path = "./combine_components.sh"
    num_parts = "1"

    try:
        result = subprocess.run(
            ["bash", script_path, num_parts], check=True, capture_output=True, text=True
        )
        if result.stderr:
            logging.warning(
                f"Issues during script execution, but continuing: {result.stderr}"
            )
        else:
            logging.info("Files generated and ready for upload.")
    except subprocess.CalledProcessError as e:
        logging.error(f"Script execution failed: {e.stderr}")
        return []

    part_files = glob.glob("./noredinkuicomponentspart*.md")
    if not part_files:
        logging.error("No files were generated by the script.")
        return []

    upload_tasks = [upload_file(part_file) for part_file in part_files]
    file_ids = await asyncio.gather(*upload_tasks, return_exceptions=True)

    # clean up generated files
    for part_file in part_files:
        try:
            os.remove(part_file)
        except Exception as e:
            logging.warning(f"Failed to delete file {part_file}: {e}")

    return [file_id for file_id in file_ids if file_id is not None]


async def list_files(assistant_id):
    try:
        assistant_files = await client.beta.assistants.files.list(
            assistant_id=assistant_id
        )
        return assistant_files.data
    except Exception as e:
        logging.error(f"Failed to list files for assistant {assistant_id}: {e}")
        return []


async def delete_file(file_id):
    try:
        deleted_file = await client.files.delete(file_id)
        logging.info(f"Deleted file {file_id} successfully.")
        return deleted_file
    except Exception as e:
        logging.error(f"Failed to delete file {file_id}: {e}")
        return None


async def delete_old_files(assistant_id):
    files = await list_files(assistant_id)
    delete_tasks = [delete_file(file.id) for file in files]
    await asyncio.gather(*delete_tasks)


async def main():
    assistant = await retrieve_assistant_by_name(ASSISTANT_NAME)
    file_ids = await generate_and_upload_files()
    if not file_ids:
        logging.error("No files to upload. Aborting assistant creation/update.")
        return

    if assistant:
        logging.info(f"Deleting old files for assistant: {ASSISTANT_NAME}")
        await delete_old_files(assistant.id)

        logging.info(f"Updating existing assistant: {ASSISTANT_NAME}")
        try:
            await client.beta.assistants.update(
                assistant.id,
                name=ASSISTANT_NAME,
                instructions=ASSISTANT_INSTRUCTIONS.format(name=ASSISTANT_NAME),
                model=MODEL,
                tools=TOOLS,
                file_ids=file_ids,
            )
            logging.info(f"{ASSISTANT_NAME} updated successfully.")
        except Exception as e:
            logging.error(f"Failed to update assistant: {e}")
    else:
        logging.info(f"Creating new assistant: {ASSISTANT_NAME}")
        try:
            assistant = await client.beta.assistants.create(
                name=ASSISTANT_NAME,
                instructions=ASSISTANT_INSTRUCTIONS.format(name=ASSISTANT_NAME),
                model=MODEL,
                tools=TOOLS,
                file_ids=file_ids,
            )
            logging.info(
                f"Assistant {ASSISTANT_NAME} created successfully with ID: {assistant.id}"
            )
        except Exception as e:
            logging.error(f"Failed to create assistant: {e}")


if __name__ == "__main__":
    asyncio.run(main())
